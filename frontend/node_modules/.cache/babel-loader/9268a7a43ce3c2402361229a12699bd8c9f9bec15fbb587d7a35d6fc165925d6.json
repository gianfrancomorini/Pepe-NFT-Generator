{"ast":null,"code":"'use strict';\n\nconst sortLinks = require('./sortLinks');\nconst DAGLink = require('../dag-link/dagLink');\n\n/**\n * @typedef {import('./dagNode')} DAGNode\n * @typedef {import('../types')} DAGLinkLike\n */\n\n/**\n * @param {*} link\n * @returns {DAGLink}\n */\nconst asDAGLink = link => {\n  if (link instanceof DAGLink) {\n    // It's a DAGLink instance\n    // no need to do anything\n    return link;\n  }\n\n  // DAGNode.isDagNode() would be more appropriate here, but it can't be used\n  // as it would lead to circular dependencies as `addLink` is called from\n  // within the DAGNode object.\n  if (!('cid' in link || 'hash' in link || 'Hash' in link || 'multihash' in link)) {\n    throw new Error('Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`.');\n  }\n\n  // It's a Object with name, multihash/hash/cid and size\n  // @ts-ignore\n  return new DAGLink(link.Name || link.name, link.Tsize || link.size, link.Hash || link.multihash || link.hash || link.cid);\n};\n\n/**\n * @param {DAGNode} node\n * @param {DAGLink | DAGLinkLike} link\n */\nconst addLink = (node, link) => {\n  const dagLink = asDAGLink(link);\n  node.Links.push(dagLink);\n  sortLinks(node.Links);\n};\nmodule.exports = addLink;","map":{"version":3,"names":["sortLinks","require","DAGLink","asDAGLink","link","Error","Name","name","Tsize","size","Hash","multihash","hash","cid","addLink","node","dagLink","Links","push","module","exports"],"sources":["/Users/gianfrancomorini/Pepe-NFT-Generator/node_modules/ipld-dag-pb/src/dag-node/addLink.js"],"sourcesContent":["'use strict'\n\nconst sortLinks = require('./sortLinks')\nconst DAGLink = require('../dag-link/dagLink')\n\n/**\n * @typedef {import('./dagNode')} DAGNode\n * @typedef {import('../types')} DAGLinkLike\n */\n\n/**\n * @param {*} link\n * @returns {DAGLink}\n */\nconst asDAGLink = (link) => {\n  if (link instanceof DAGLink) {\n    // It's a DAGLink instance\n    // no need to do anything\n    return link\n  }\n\n  // DAGNode.isDagNode() would be more appropriate here, but it can't be used\n  // as it would lead to circular dependencies as `addLink` is called from\n  // within the DAGNode object.\n  if (!('cid' in link ||\n        'hash' in link ||\n        'Hash' in link ||\n        'multihash' in link)) {\n    throw new Error('Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`.')\n  }\n\n  // It's a Object with name, multihash/hash/cid and size\n  // @ts-ignore\n  return new DAGLink(link.Name || link.name, link.Tsize || link.size, link.Hash || link.multihash || link.hash || link.cid)\n}\n\n/**\n * @param {DAGNode} node\n * @param {DAGLink | DAGLinkLike} link\n */\nconst addLink = (node, link) => {\n  const dagLink = asDAGLink(link)\n  node.Links.push(dagLink)\n  sortLinks(node.Links)\n}\n\nmodule.exports = addLink\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMC,OAAO,GAAGD,OAAO,CAAC,qBAAqB,CAAC;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAME,SAAS,GAAIC,IAAI,IAAK;EAC1B,IAAIA,IAAI,YAAYF,OAAO,EAAE;IAC3B;IACA;IACA,OAAOE,IAAI;EACb;;EAEA;EACA;EACA;EACA,IAAI,EAAE,KAAK,IAAIA,IAAI,IACb,MAAM,IAAIA,IAAI,IACd,MAAM,IAAIA,IAAI,IACd,WAAW,IAAIA,IAAI,CAAC,EAAE;IAC1B,MAAM,IAAIC,KAAK,CAAC,oGAAoG,CAAC;EACvH;;EAEA;EACA;EACA,OAAO,IAAIH,OAAO,CAACE,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACG,IAAI,EAAEH,IAAI,CAACI,KAAK,IAAIJ,IAAI,CAACK,IAAI,EAAEL,IAAI,CAACM,IAAI,IAAIN,IAAI,CAACO,SAAS,IAAIP,IAAI,CAACQ,IAAI,IAAIR,IAAI,CAACS,GAAG,CAAC;AAC3H,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAGA,CAACC,IAAI,EAAEX,IAAI,KAAK;EAC9B,MAAMY,OAAO,GAAGb,SAAS,CAACC,IAAI,CAAC;EAC/BW,IAAI,CAACE,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC;EACxBhB,SAAS,CAACe,IAAI,CAACE,KAAK,CAAC;AACvB,CAAC;AAEDE,MAAM,CAACC,OAAO,GAAGN,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}