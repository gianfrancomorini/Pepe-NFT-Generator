{"ast":null,"code":"const defer = require('p-defer');\nconst Headers = require('./extract-headers');\nconst LteReader = require('./lte-reader');\nfunction getPadding(size) {\n  size &= 511;\n  return size && 512 - size;\n}\nasync function discardPadding(reader, size) {\n  const overflow = getPadding(size);\n  if (overflow) await reader.next(overflow);\n}\nmodule.exports = options => {\n  options = options || {};\n  options.highWaterMark = options.highWaterMark || 1024 * 16;\n  return source => async function* () {\n    const reader = LteReader(source);\n    let gnuLongPath, gnuLongLinkPath, paxGlobal, pax;\n    try {\n      while (true) {\n        let headerBytes;\n        try {\n          const {\n            done,\n            value\n          } = await reader.next(512);\n          if (done) return;\n          headerBytes = value;\n        } catch (err) {\n          // Is ok, this is the end of the stream!\n          if (err.code === 'ERR_UNDER_READ') return;\n          throw err;\n        }\n        const header = Headers.decode(headerBytes, options.filenameEncoding);\n        if (!header) continue;\n        if (header.type === 'gnu-long-path') {\n          const {\n            done,\n            value: gnuLongPathBytes\n          } = await reader.next(header.size);\n          if (done) return;\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding);\n          await discardPadding(reader, header.size);\n          continue;\n        }\n        if (header.type === 'gnu-long-link-path') {\n          const {\n            done,\n            value: gnuLongLinkPathBytes\n          } = await reader.next(header.size);\n          if (done) return;\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding);\n          await discardPadding(reader, header.size);\n          continue;\n        }\n        if (header.type === 'pax-global-header') {\n          const {\n            done,\n            value: paxGlobalBytes\n          } = await reader.next(header.size);\n          if (done) return;\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding);\n          await discardPadding(reader, header.size);\n          continue;\n        }\n        if (header.type === 'pax-header') {\n          const {\n            done,\n            value: paxBytes\n          } = await reader.next(header.size);\n          if (done) return;\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding);\n          if (paxGlobal) pax = {\n            ...paxGlobal,\n            ...pax\n          };\n          await discardPadding(reader, header.size);\n          continue;\n        }\n        if (gnuLongPath) {\n          header.name = gnuLongPath;\n          gnuLongPath = null;\n        }\n        if (gnuLongLinkPath) {\n          header.linkname = gnuLongLinkPath;\n          gnuLongLinkPath = null;\n        }\n        if (pax) {\n          if (pax.path) header.name = pax.path;\n          if (pax.linkpath) header.linkname = pax.linkpath;\n          if (pax.size) header.size = parseInt(pax.size, 10);\n          header.pax = pax;\n          pax = null;\n        }\n        if (!header.size || header.type === 'directory') {\n          yield {\n            header,\n            body: async function* () {}()\n          };\n          continue;\n        }\n        let bytesRemaining = header.size;\n        const bodyConsumed = defer();\n\n        // Prefetch the first chunk.\n        // This allows us to stream entries for small files from the tar without\n        // explicitly streaming the body of each.\n        const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark));\n        bytesRemaining -= firstChunk.value.length;\n        if (!bytesRemaining) bodyConsumed.resolve();\n        const body = async function* () {\n          try {\n            yield firstChunk.value;\n            while (bytesRemaining) {\n              const {\n                done,\n                value\n              } = await reader.nextLte(bytesRemaining);\n              if (done) {\n                bytesRemaining = 0;\n                return;\n              }\n              bytesRemaining -= value.length;\n              yield value;\n            }\n          } finally {\n            bodyConsumed.resolve();\n          }\n        }();\n        yield {\n          header,\n          body\n        };\n\n        // Wait for the body to be consumed\n        await bodyConsumed.promise;\n\n        // Incase the body was not consumed entirely...\n        if (bytesRemaining) {\n          for await (const _ of body) {} // eslint-disable-line no-unused-vars,no-empty\n        }\n        await discardPadding(reader, header.size);\n      }\n    } finally {\n      await reader.return();\n    }\n  }();\n};","map":{"version":3,"names":["defer","require","Headers","LteReader","getPadding","size","discardPadding","reader","overflow","next","module","exports","options","highWaterMark","source","gnuLongPath","gnuLongLinkPath","paxGlobal","pax","headerBytes","done","value","err","code","header","decode","filenameEncoding","type","gnuLongPathBytes","decodeLongPath","gnuLongLinkPathBytes","paxGlobalBytes","decodePax","paxBytes","name","linkname","path","linkpath","parseInt","body","bytesRemaining","bodyConsumed","firstChunk","nextLte","Math","min","length","resolve","promise","_","return"],"sources":["/Users/gianfrancomorini/Pepe-NFT-Generator/node_modules/it-tar/extract.js"],"sourcesContent":["const defer = require('p-defer')\nconst Headers = require('./extract-headers')\nconst LteReader = require('./lte-reader')\n\nfunction getPadding (size) {\n  size &= 511\n  return size && 512 - size\n}\n\nasync function discardPadding (reader, size) {\n  const overflow = getPadding(size)\n  if (overflow) await reader.next(overflow)\n}\n\nmodule.exports = options => {\n  options = options || {}\n  options.highWaterMark = options.highWaterMark || 1024 * 16\n\n  return source => (async function * () {\n    const reader = LteReader(source)\n    let gnuLongPath, gnuLongLinkPath, paxGlobal, pax\n\n    try {\n      while (true) {\n        let headerBytes\n        try {\n          const { done, value } = await reader.next(512)\n          if (done) return\n          headerBytes = value\n        } catch (err) {\n          // Is ok, this is the end of the stream!\n          if (err.code === 'ERR_UNDER_READ') return\n          throw err\n        }\n\n        const header = Headers.decode(headerBytes, options.filenameEncoding)\n        if (!header) continue\n\n        if (header.type === 'gnu-long-path') {\n          const { done, value: gnuLongPathBytes } = await reader.next(header.size)\n          if (done) return\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'gnu-long-link-path') {\n          const { done, value: gnuLongLinkPathBytes } = await reader.next(header.size)\n          if (done) return\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-global-header') {\n          const { done, value: paxGlobalBytes } = await reader.next(header.size)\n          if (done) return\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-header') {\n          const { done, value: paxBytes } = await reader.next(header.size)\n          if (done) return\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding)\n          if (paxGlobal) pax = { ...paxGlobal, ...pax }\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (gnuLongPath) {\n          header.name = gnuLongPath\n          gnuLongPath = null\n        }\n\n        if (gnuLongLinkPath) {\n          header.linkname = gnuLongLinkPath\n          gnuLongLinkPath = null\n        }\n\n        if (pax) {\n          if (pax.path) header.name = pax.path\n          if (pax.linkpath) header.linkname = pax.linkpath\n          if (pax.size) header.size = parseInt(pax.size, 10)\n          header.pax = pax\n          pax = null\n        }\n\n        if (!header.size || header.type === 'directory') {\n          yield { header, body: (async function * () {})() }\n          continue\n        }\n\n        let bytesRemaining = header.size\n        const bodyConsumed = defer()\n\n        // Prefetch the first chunk.\n        // This allows us to stream entries for small files from the tar without\n        // explicitly streaming the body of each.\n        const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark))\n        bytesRemaining -= firstChunk.value.length\n\n        if (!bytesRemaining) bodyConsumed.resolve()\n\n        const body = (async function * () {\n          try {\n            yield firstChunk.value\n\n            while (bytesRemaining) {\n              const { done, value } = await reader.nextLte(bytesRemaining)\n              if (done) {\n                bytesRemaining = 0\n                return\n              }\n              bytesRemaining -= value.length\n              yield value\n            }\n          } finally {\n            bodyConsumed.resolve()\n          }\n        })()\n\n        yield { header, body }\n\n        // Wait for the body to be consumed\n        await bodyConsumed.promise\n\n        // Incase the body was not consumed entirely...\n        if (bytesRemaining) {\n          for await (const _ of body) {} // eslint-disable-line no-unused-vars,no-empty\n        }\n\n        await discardPadding(reader, header.size)\n      }\n    } finally {\n      await reader.return()\n    }\n  })()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}