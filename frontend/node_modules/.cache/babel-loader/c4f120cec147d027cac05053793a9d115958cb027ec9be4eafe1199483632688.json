{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\n/**\n * @typedef {import('../dag-link/dagLink')} DAGLink\n */\n\n/**\n *\n * @param {import('./dagNode')} dagNode\n * @param {string | CID | Uint8Array | DAGLink} nameOrCid\n */\nconst rmLink = (dagNode, nameOrCid) => {\n  let predicate = null;\n\n  // It's a name\n  if (typeof nameOrCid === 'string') {\n    predicate = (/** @type {DAGLink} */link) => link.Name === nameOrCid;\n  } else if (nameOrCid instanceof Uint8Array) {\n    predicate = (/** @type {DAGLink} */link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid);\n  } else if (CID.isCID(nameOrCid)) {\n    predicate = (/** @type {DAGLink} */link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid.bytes);\n  }\n  if (predicate) {\n    const links = dagNode.Links;\n    let index = 0;\n    while (index < links.length) {\n      const link = links[index];\n      if (predicate(link)) {\n        links.splice(index, 1);\n      } else {\n        index++;\n      }\n    }\n  } else {\n    throw new Error('second arg needs to be a name or CID');\n  }\n};\nmodule.exports = rmLink;","map":{"version":3,"names":["CID","require","uint8ArrayEquals","rmLink","dagNode","nameOrCid","predicate","link","Name","Uint8Array","Hash","bytes","isCID","links","Links","index","length","splice","Error","module","exports"],"sources":["/Users/gianfrancomorini/Pepe-NFT-Generator/node_modules/ipld-dag-pb/src/dag-node/rmLink.js"],"sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\n/**\n * @typedef {import('../dag-link/dagLink')} DAGLink\n */\n\n/**\n *\n * @param {import('./dagNode')} dagNode\n * @param {string | CID | Uint8Array | DAGLink} nameOrCid\n */\nconst rmLink = (dagNode, nameOrCid) => {\n  let predicate = null\n\n  // It's a name\n  if (typeof nameOrCid === 'string') {\n    predicate = (/** @type {DAGLink} */ link) => link.Name === nameOrCid\n  } else if (nameOrCid instanceof Uint8Array) {\n    predicate = (/** @type {DAGLink} */ link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid)\n  } else if (CID.isCID(nameOrCid)) {\n    predicate = (/** @type {DAGLink} */ link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid.bytes)\n  }\n\n  if (predicate) {\n    const links = dagNode.Links\n    let index = 0\n    while (index < links.length) {\n      const link = links[index]\n      if (predicate(link)) {\n        links.splice(index, 1)\n      } else {\n        index++\n      }\n    }\n  } else {\n    throw new Error('second arg needs to be a name or CID')\n  }\n}\n\nmodule.exports = rmLink\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC3B,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,oBAAoB,CAAC;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAME,MAAM,GAAGA,CAACC,OAAO,EAAEC,SAAS,KAAK;EACrC,IAAIC,SAAS,GAAG,IAAI;;EAEpB;EACA,IAAI,OAAOD,SAAS,KAAK,QAAQ,EAAE;IACjCC,SAAS,GAAGA,CAAC,sBAAuBC,IAAI,KAAKA,IAAI,CAACC,IAAI,KAAKH,SAAS;EACtE,CAAC,MAAM,IAAIA,SAAS,YAAYI,UAAU,EAAE;IAC1CH,SAAS,GAAGA,CAAC,sBAAuBC,IAAI,KAAKL,gBAAgB,CAACK,IAAI,CAACG,IAAI,CAACC,KAAK,EAAEN,SAAS,CAAC;EAC3F,CAAC,MAAM,IAAIL,GAAG,CAACY,KAAK,CAACP,SAAS,CAAC,EAAE;IAC/BC,SAAS,GAAGA,CAAC,sBAAuBC,IAAI,KAAKL,gBAAgB,CAACK,IAAI,CAACG,IAAI,CAACC,KAAK,EAAEN,SAAS,CAACM,KAAK,CAAC;EACjG;EAEA,IAAIL,SAAS,EAAE;IACb,MAAMO,KAAK,GAAGT,OAAO,CAACU,KAAK;IAC3B,IAAIC,KAAK,GAAG,CAAC;IACb,OAAOA,KAAK,GAAGF,KAAK,CAACG,MAAM,EAAE;MAC3B,MAAMT,IAAI,GAAGM,KAAK,CAACE,KAAK,CAAC;MACzB,IAAIT,SAAS,CAACC,IAAI,CAAC,EAAE;QACnBM,KAAK,CAACI,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;MACxB,CAAC,MAAM;QACLA,KAAK,EAAE;MACT;IACF;EACF,CAAC,MAAM;IACL,MAAM,IAAIG,KAAK,CAAC,sCAAsC,CAAC;EACzD;AACF,CAAC;AAEDC,MAAM,CAACC,OAAO,GAAGjB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}