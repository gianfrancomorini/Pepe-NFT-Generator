{"ast":null,"code":"'use strict';\n\nconst protobuf = require('protobufjs/minimal');\nconst {\n  PBLink\n} = require('./dag');\nconst {\n  createDagLinkFromB58EncodedHash\n} = require('./dag-link/util');\n\n/**\n * @typedef {import('./dag-link/dagLink')} DAGLink\n * @typedef {import('./types').DAGLinkLike} DAGLinkLike\n * @typedef {import('./types').SerializableDAGNode} SerializableDAGNode\n * @typedef {import('cids')} CID\n */\n\n/**\n * @param { { Data?: Uint8Array, Links: (DAGLink | DAGLinkLike)[] }} node\n * @returns {SerializableDAGNode}\n */\nconst toProtoBuf = node => {\n  const pbn = {};\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null;\n  }\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(link => ({\n      Hash: link.Hash.bytes,\n      Name: link.Name,\n      Tsize: link.Tsize\n    }));\n  } else {\n    pbn.Links = null;\n  }\n  return pbn;\n};\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {import('./dag-node/dagNode')} node - Internal representation of a PB block\n */\nconst serializeDAGNode = node => {\n  return encode(toProtoBuf(node));\n};\n\n/**\n * Serialize an object where the `Links` might not be a `DAGLink` instance yet\n *\n * @param {Uint8Array} [data]\n * @param {(DAGLink | string | DAGLinkLike)[]} [links]\n */\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = {\n    Data: data,\n    Links: links.map(link => {\n      return createDagLinkFromB58EncodedHash(link);\n    })\n  };\n  return encode(toProtoBuf(node));\n};\nmodule.exports = {\n  serializeDAGNode,\n  serializeDAGNodeLike\n};\n\n/**\n * The fields in PBNode are the wrong way round - `id: 2` comes before\n * `id: 1`. protobufjs writes them out in id order but go-IPFS does not so\n * we have to use the protobuf.Writer interface directly to get the same\n * serialized form as go-IPFS\n *\n * @param {SerializableDAGNode} pbf\n */\nfunction encode(pbf) {\n  const writer = protobuf.Writer.create();\n  if (pbf.Links != null) {\n    for (let i = 0; i < pbf.Links.length; i++) {\n      PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim();\n    }\n  }\n  if (pbf.Data != null) {\n    writer.uint32(10).bytes(pbf.Data);\n  }\n  return writer.finish();\n}","map":{"version":3,"names":["protobuf","require","PBLink","createDagLinkFromB58EncodedHash","toProtoBuf","node","pbn","Data","byteLength","Links","length","map","link","Hash","bytes","Name","Tsize","serializeDAGNode","encode","serializeDAGNodeLike","data","links","module","exports","pbf","writer","Writer","create","i","uint32","fork","ldelim","finish"],"sources":["/Users/gianfrancomorini/Pepe-NFT-Generator/node_modules/ipld-dag-pb/src/serialize.js"],"sourcesContent":["'use strict'\n\nconst protobuf = require('protobufjs/minimal')\nconst {\n  PBLink\n} = require('./dag')\n\nconst {\n  createDagLinkFromB58EncodedHash\n} = require('./dag-link/util')\n\n/**\n * @typedef {import('./dag-link/dagLink')} DAGLink\n * @typedef {import('./types').DAGLinkLike} DAGLinkLike\n * @typedef {import('./types').SerializableDAGNode} SerializableDAGNode\n * @typedef {import('cids')} CID\n */\n\n/**\n * @param { { Data?: Uint8Array, Links: (DAGLink | DAGLinkLike)[] }} node\n * @returns {SerializableDAGNode}\n */\nconst toProtoBuf = (node) => {\n  const pbn = {}\n\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.bytes,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {import('./dag-node/dagNode')} node - Internal representation of a PB block\n */\nconst serializeDAGNode = (node) => {\n  return encode(toProtoBuf(node))\n}\n\n/**\n * Serialize an object where the `Links` might not be a `DAGLink` instance yet\n *\n * @param {Uint8Array} [data]\n * @param {(DAGLink | string | DAGLinkLike)[]} [links]\n */\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = {\n    Data: data,\n    Links: links.map((link) => {\n      return createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  return encode(toProtoBuf(node))\n}\n\nmodule.exports = {\n  serializeDAGNode,\n  serializeDAGNodeLike\n}\n\n/**\n * The fields in PBNode are the wrong way round - `id: 2` comes before\n * `id: 1`. protobufjs writes them out in id order but go-IPFS does not so\n * we have to use the protobuf.Writer interface directly to get the same\n * serialized form as go-IPFS\n *\n * @param {SerializableDAGNode} pbf\n */\nfunction encode (pbf) {\n  const writer = protobuf.Writer.create()\n\n  if (pbf.Links != null) {\n    for (let i = 0; i < pbf.Links.length; i++) {\n      PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim()\n    }\n  }\n\n  if (pbf.Data != null) {\n    writer.uint32(10).bytes(pbf.Data)\n  }\n\n  return writer.finish()\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAM;EACJC;AACF,CAAC,GAAGD,OAAO,CAAC,OAAO,CAAC;AAEpB,MAAM;EACJE;AACF,CAAC,GAAGF,OAAO,CAAC,iBAAiB,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMG,UAAU,GAAIC,IAAI,IAAK;EAC3B,MAAMC,GAAG,GAAG,CAAC,CAAC;EAEd,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACE,IAAI,CAACC,UAAU,GAAG,CAAC,EAAE;IACzCF,GAAG,CAACC,IAAI,GAAGF,IAAI,CAACE,IAAI;EACtB,CAAC,MAAM;IACL;IACA;IACAD,GAAG,CAACC,IAAI,GAAG,IAAI;EACjB;EAEA,IAAIF,IAAI,CAACI,KAAK,IAAIJ,IAAI,CAACI,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IACvCJ,GAAG,CAACG,KAAK,GAAGJ,IAAI,CAACI,KAAK,CACnBE,GAAG,CAAEC,IAAI,KAAM;MACdC,IAAI,EAAED,IAAI,CAACC,IAAI,CAACC,KAAK;MACrBC,IAAI,EAAEH,IAAI,CAACG,IAAI;MACfC,KAAK,EAAEJ,IAAI,CAACI;IACd,CAAC,CAAC,CAAC;EACP,CAAC,MAAM;IACLV,GAAG,CAACG,KAAK,GAAG,IAAI;EAClB;EAEA,OAAOH,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMW,gBAAgB,GAAIZ,IAAI,IAAK;EACjC,OAAOa,MAAM,CAACd,UAAU,CAACC,IAAI,CAAC,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMc,oBAAoB,GAAGA,CAACC,IAAI,EAAEC,KAAK,GAAG,EAAE,KAAK;EACjD,MAAMhB,IAAI,GAAG;IACXE,IAAI,EAAEa,IAAI;IACVX,KAAK,EAAEY,KAAK,CAACV,GAAG,CAAEC,IAAI,IAAK;MACzB,OAAOT,+BAA+B,CAACS,IAAI,CAAC;IAC9C,CAAC;EACH,CAAC;EAED,OAAOM,MAAM,CAACd,UAAU,CAACC,IAAI,CAAC,CAAC;AACjC,CAAC;AAEDiB,MAAM,CAACC,OAAO,GAAG;EACfN,gBAAgB;EAChBE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,MAAMA,CAAEM,GAAG,EAAE;EACpB,MAAMC,MAAM,GAAGzB,QAAQ,CAAC0B,MAAM,CAACC,MAAM,CAAC,CAAC;EAEvC,IAAIH,GAAG,CAACf,KAAK,IAAI,IAAI,EAAE;IACrB,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACf,KAAK,CAACC,MAAM,EAAEkB,CAAC,EAAE,EAAE;MACzC1B,MAAM,CAACgB,MAAM,CAACM,GAAG,CAACf,KAAK,CAACmB,CAAC,CAAC,EAAEH,MAAM,CAACI,MAAM,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAChE;EACF;EAEA,IAAIP,GAAG,CAACjB,IAAI,IAAI,IAAI,EAAE;IACpBkB,MAAM,CAACI,MAAM,CAAC,EAAE,CAAC,CAACf,KAAK,CAACU,GAAG,CAACjB,IAAI,CAAC;EACnC;EAEA,OAAOkB,MAAM,CAACO,MAAM,CAAC,CAAC;AACxB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}