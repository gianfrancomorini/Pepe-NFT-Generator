{"ast":null,"code":"'use strict';\n\n// @ts-ignore TODO: switch to cborg\nconst cbor = require('borc');\nconst multicodec = require('multicodec');\nconst multihashing = require('multihashing-async');\nconst {\n  multihash\n} = multihashing;\nconst CID = require('cids');\n// @ts-ignore\nconst isCircular = require('is-circular');\nconst uint8ArrayConcat = require('uint8arrays/concat');\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\n/**\n * @typedef {import('cids').CIDVersion} CIDVersion\n * @typedef {import('multihashing-async').multihash.HashCode} HashCode\n */\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42;\n\n/**\n * @param {CID | string} cid\n */\nfunction tagCID(cid) {\n  let buf;\n  if (typeof cid === 'string') {\n    buf = new CID(cid).bytes;\n  } else if (CID.isCID(cid)) {\n    buf = cid.bytes;\n  } else {\n    throw new Error('Could not tag CID - was not string or CID');\n  }\n  return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([uint8ArrayFromString('00', 'base16'),\n  // thanks jdag\n  buf], 1 + buf.length));\n}\n\n/**\n * @param {any} dagNode\n */\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  /**\n   * @param {any} obj\n   * @returns {any}\n   */\n  function transform(obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n    const keys = Object.keys(obj);\n    if (keys.length > 0) {\n      // Recursive transform\n      /** @type {Record<string, any>} */\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n  return transform(dagNode);\n}\nconst codec = multicodec.DAG_CBOR;\nconst defaultHashAlg = multihash.names['sha2-256'];\nconst defaultTags = {\n  /**\n   * @param {Uint8Array} val\n   */\n  [CID_CBOR_TAG]: val => {\n    // remove that 0\n    val = val.slice(1);\n    return new CID(val);\n  }\n};\nconst defaultSize = 64 * 1024; // current decoder heap size, 64 Kb\nlet currentSize = defaultSize;\nconst defaultMaxSize = 64 * 1024 * 1024; // max heap size when auto-growing, 64 Mb\nlet maxSize = defaultMaxSize;\n/** @type {cbor.Decoder} */\nlet decoder;\n\n/**\n * Configure the underlying CBOR decoder.\n *\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\n */\nfunction configureDecoder(options) {\n  let tags = defaultTags;\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size;\n    }\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize;\n    }\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags);\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize;\n    maxSize = defaultMaxSize;\n  }\n  const decoderOptions = {\n    tags,\n    size: currentSize\n  };\n  decoder = new cbor.Decoder(decoderOptions);\n  // borc edits opts.size in-place so we can capture _actual_ size\n  currentSize = decoderOptions.size;\n}\nconfigureDecoder(); // Setup default cbor.Decoder\n\n/**\n * Serialize internal representation into a binary CBOR block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Uint8Array} - The encoded binary representation\n */\nfunction serialize(node) {\n  const nodeTagged = replaceCIDbyTAG(node);\n  const serialized = cbor.encode(nodeTagged);\n  return serialized;\n}\n\n/**\n * Deserialize CBOR block into the internal representation.\n *\n * @param {Uint8Array} data - Binary representation of a CBOR block\n * @returns {any} - An object that conforms to the IPLD Data Model\n */\nfunction deserialize(data) {\n  if (data.length > currentSize && data.length <= maxSize) {\n    configureDecoder({\n      size: data.length\n    });\n  }\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder');\n  }\n\n  // borc will decode back-to-back objects into an implicit top-level array, we\n  // strictly want to only see a single explicit top-level object\n  const all = decoder.decodeAll(data);\n  if (all.length !== 1) {\n    throw new Error('Extraneous CBOR data found beyond initial top-level object');\n  }\n  return all[0];\n}\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Uint8Array} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {CIDVersion} [userOptions.cidVersion=1] - CID version number\n * @param {HashCode} [userOptions.hashAlg=multihash.names['sha2-256']] - Defaults to the defaultHashAlg of the format\n */\nasync function cid(binaryBlob, userOptions = {}) {\n  const options = {\n    cidVersion: userOptions.cidVersion == null ? 1 : userOptions.cidVersion,\n    hashAlg: userOptions.hashAlg == null ? module.exports.defaultHashAlg : userOptions.hashAlg\n  };\n  const hashName = multihash.codes[options.hashAlg];\n  const hash = await multihashing(binaryBlob, hashName);\n  const codecName = multicodec.getNameFromCode(module.exports.codec);\n  const cid = new CID(options.cidVersion, codecName, hash);\n  return cid;\n}\nmodule.exports = {\n  codec,\n  defaultHashAlg,\n  configureDecoder,\n  serialize,\n  deserialize,\n  cid\n};","map":{"version":3,"names":["cbor","require","multicodec","multihashing","multihash","CID","isCircular","uint8ArrayConcat","uint8ArrayFromString","CID_CBOR_TAG","tagCID","cid","buf","bytes","isCID","Error","Tagged","length","replaceCIDbyTAG","dagNode","circular","e","transform","obj","Uint8Array","Array","isArray","map","keys","Object","out","forEach","key","codec","DAG_CBOR","defaultHashAlg","names","defaultTags","val","slice","defaultSize","currentSize","defaultMaxSize","maxSize","decoder","configureDecoder","options","tags","size","assign","decoderOptions","Decoder","serialize","node","nodeTagged","serialized","encode","deserialize","data","all","decodeAll","binaryBlob","userOptions","cidVersion","hashAlg","module","exports","hashName","codes","hash","codecName","getNameFromCode"],"sources":["/Users/gianfrancomorini/Pepe-NFT-Generator/node_modules/ipld-dag-cbor/src/util.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore TODO: switch to cborg\nconst cbor = require('borc')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\nconst { multihash } = multihashing\nconst CID = require('cids')\n// @ts-ignore\nconst isCircular = require('is-circular')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('cids').CIDVersion} CIDVersion\n * @typedef {import('multihashing-async').multihash.HashCode} HashCode\n */\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @param {CID | string} cid\n */\nfunction tagCID (cid) {\n  let buf\n\n  if (typeof cid === 'string') {\n    buf = new CID(cid).bytes\n  } else if (CID.isCID(cid)) {\n    buf = cid.bytes\n  } else {\n    throw new Error('Could not tag CID - was not string or CID')\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([\n    uint8ArrayFromString('00', 'base16'), // thanks jdag\n    buf\n  ], 1 + buf.length))\n}\n\n/**\n * @param {any} dagNode\n */\nfunction replaceCIDbyTAG (dagNode) {\n  let circular\n  try {\n    circular = isCircular(dagNode)\n  } catch (e) {\n    circular = false\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references')\n  }\n\n  /**\n   * @param {any} obj\n   * @returns {any}\n   */\n  function transform (obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform)\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj)\n    }\n\n    const keys = Object.keys(obj)\n\n    if (keys.length > 0) {\n      // Recursive transform\n      /** @type {Record<string, any>} */\n      const out = {}\n      keys.forEach((key) => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key])\n        } else {\n          out[key] = obj[key]\n        }\n      })\n      return out\n    } else {\n      return obj\n    }\n  }\n\n  return transform(dagNode)\n}\n\nconst codec = multicodec.DAG_CBOR\nconst defaultHashAlg = multihash.names['sha2-256']\n\nconst defaultTags = {\n  /**\n   * @param {Uint8Array} val\n   */\n  [CID_CBOR_TAG]: (val) => {\n    // remove that 0\n    val = val.slice(1)\n    return new CID(val)\n  }\n}\nconst defaultSize = 64 * 1024 // current decoder heap size, 64 Kb\nlet currentSize = defaultSize\nconst defaultMaxSize = 64 * 1024 * 1024 // max heap size when auto-growing, 64 Mb\nlet maxSize = defaultMaxSize\n/** @type {cbor.Decoder} */\nlet decoder\n\n/**\n * Configure the underlying CBOR decoder.\n *\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\n */\nfunction configureDecoder (options) {\n  let tags = defaultTags\n\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size\n    }\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize\n    }\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags)\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize\n    maxSize = defaultMaxSize\n  }\n\n  const decoderOptions = {\n    tags,\n    size: currentSize\n  }\n\n  decoder = new cbor.Decoder(decoderOptions)\n  // borc edits opts.size in-place so we can capture _actual_ size\n  currentSize = decoderOptions.size\n}\n\nconfigureDecoder() // Setup default cbor.Decoder\n\n/**\n * Serialize internal representation into a binary CBOR block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Uint8Array} - The encoded binary representation\n */\nfunction serialize (node) {\n  const nodeTagged = replaceCIDbyTAG(node)\n  const serialized = cbor.encode(nodeTagged)\n\n  return serialized\n}\n\n/**\n * Deserialize CBOR block into the internal representation.\n *\n * @param {Uint8Array} data - Binary representation of a CBOR block\n * @returns {any} - An object that conforms to the IPLD Data Model\n */\nfunction deserialize (data) {\n  if (data.length > currentSize && data.length <= maxSize) {\n    configureDecoder({ size: data.length })\n  }\n\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder')\n  }\n\n  // borc will decode back-to-back objects into an implicit top-level array, we\n  // strictly want to only see a single explicit top-level object\n  const all = decoder.decodeAll(data)\n  if (all.length !== 1) {\n    throw new Error('Extraneous CBOR data found beyond initial top-level object')\n  }\n\n  return all[0]\n}\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Uint8Array} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {CIDVersion} [userOptions.cidVersion=1] - CID version number\n * @param {HashCode} [userOptions.hashAlg=multihash.names['sha2-256']] - Defaults to the defaultHashAlg of the format\n */\nasync function cid (binaryBlob, userOptions = {}) {\n  const options = {\n    cidVersion: userOptions.cidVersion == null ? 1 : userOptions.cidVersion,\n    hashAlg: userOptions.hashAlg == null ? module.exports.defaultHashAlg : userOptions.hashAlg\n  }\n\n  const hashName = multihash.codes[options.hashAlg]\n  const hash = await multihashing(binaryBlob, hashName)\n  const codecName = multicodec.getNameFromCode(module.exports.codec)\n  const cid = new CID(options.cidVersion, codecName, hash)\n\n  return cid\n}\n\nmodule.exports = {\n  codec,\n  defaultHashAlg,\n  configureDecoder,\n  serialize,\n  deserialize,\n  cid\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}