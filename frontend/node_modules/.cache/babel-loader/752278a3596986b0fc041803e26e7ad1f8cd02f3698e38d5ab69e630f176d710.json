{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\nconst multihash = require('multihashes');\nconst crypto = require('./crypto');\nconst {\n  equals\n} = require('uint8arrays/equals');\n\n/**\n * @typedef {import(\"./types\").Digest} Digest\n * @typedef {import(\"multihashes\").HashName} HashName\n */\n\n/**\n * Hash the given `bytes` using the algorithm specified by `alg`.\n *\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\nasync function Multihashing(bytes, alg, length) {\n  const digest = await Multihashing.digest(bytes, alg, length);\n  return multihash.encode(digest, alg, length);\n}\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash;\n\n/**\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\nMultihashing.digest = async (bytes, alg, length) => {\n  const hash = Multihashing.createHash(alg);\n  const digest = await hash(bytes);\n  return length ? digest.slice(0, length) : digest;\n};\n\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @returns {Digest} - The hash function corresponding to `alg`\n */\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n    throw e;\n  }\n  const code = multihash.coerceCode(alg);\n  if (!Multihashing.functions[code]) {\n    throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n  return Multihashing.functions[code];\n};\n\n/**\n * Mapping of multihash codes to their hashing functions.\n *\n * @type {Record<number, Digest>}\n */\n// @ts-ignore - most of those functions aren't typed\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n};\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions);\n\n/**\n * @param {Uint8Array} bytes\n * @param {Uint8Array} hash\n * @returns {Promise<boolean>}\n */\nMultihashing.validate = async (bytes, hash) => {\n  const newHash = await Multihashing(bytes, multihash.decode(hash).name);\n  return equals(hash, newHash);\n};\nmodule.exports = Multihashing;","map":{"version":3,"names":["errcode","require","multihash","crypto","equals","Multihashing","bytes","alg","length","digest","encode","hash","createHash","slice","e","Error","code","coerceCode","functions","identity","sha1","sha2256","sha2512","sha3512","sha3384","sha3256","sha3224","shake128","shake256","keccak224","keccak256","keccak384","keccak512","murmur3128","murmur332","dblSha2256","addBlake","validate","newHash","decode","name","module","exports"],"sources":["/Users/gianfrancomorini/Pepe-NFT-Generator/node_modules/multihashing-async/src/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst multihash = require('multihashes')\nconst crypto = require('./crypto')\nconst { equals } = require('uint8arrays/equals')\n\n/**\n * @typedef {import(\"./types\").Digest} Digest\n * @typedef {import(\"multihashes\").HashName} HashName\n */\n\n/**\n * Hash the given `bytes` using the algorithm specified by `alg`.\n *\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\nasync function Multihashing (bytes, alg, length) {\n  const digest = await Multihashing.digest(bytes, alg, length)\n  return multihash.encode(digest, alg, length)\n}\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash\n\n/**\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\nMultihashing.digest = async (bytes, alg, length) => {\n  const hash = Multihashing.createHash(alg)\n  const digest = await hash(bytes)\n  return length ? digest.slice(0, length) : digest\n}\n\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @returns {Digest} - The hash function corresponding to `alg`\n */\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')\n    throw e\n  }\n\n  const code = multihash.coerceCode(alg)\n  if (!Multihashing.functions[code]) {\n    throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')\n  }\n\n  return Multihashing.functions[code]\n}\n\n/**\n * Mapping of multihash codes to their hashing functions.\n *\n * @type {Record<number, Digest>}\n */\n// @ts-ignore - most of those functions aren't typed\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions)\n\n/**\n * @param {Uint8Array} bytes\n * @param {Uint8Array} hash\n * @returns {Promise<boolean>}\n */\nMultihashing.validate = async (bytes, hash) => {\n  const newHash = await Multihashing(bytes, multihash.decode(hash).name)\n\n  return equals(hash, newHash)\n}\n\nmodule.exports = Multihashing\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}